## 1.1 스프링이란?

대부분의 애플리케이션은 애플리케이션 전체 기능 중 일부를 담당하는 많은 컴포넌트로 구성되며, 각 컴포넌트는 다른 애플리케이션 구성 요소와 협력해서 작업을 처리한다. 애플리케이션이 실행될 때는 각 컴포넌트가 어떻게든 생성되어야 하고 상호 간에 알 수 있어야 한다.

스프링은 **스프링 애플리케이션 컨텍스트Spring application context**라는 **컨테이너container**를 제공하는데, 이것은 애플리케이션 컴포넌트들을 **생성**하고 **관리**한다. 그리고 애플리케이션 컴포넌트 또는 빈bean들은 스프링 애플리케이션 컨텍스트 내부에서 서로 연결되어 완전한 애플리케이션을 만든다. 

빈의 상호 연결은 **의존성 주입Dependency Injection, DI**이라고 알려진 패턴을 기반으로 수행된다. 즉, 애플리케이션 컴포넌트에서 의존(사용)하는 다른 빈의 생성과 관리를 자체적으로 하는 대신 별도의 개체(컨테이너)가 해주며, 이 개체에서는 모든 컴포넌트를 생성, 관리하고 해당 컴포넌트를 필요로 하는 빈에 주입(연결)한다. 일반적으로 이것은 생성자 인자 또는 속성의 접근자 메서드를 통해 처리된다.

핵심 컨테이너 외에도 스프링과 관련 라이브러리에서는 웹 프레임워크, 다양한 데이터 저장 옵션, 보안 프레임워크, 타 시스템과의 통합, 런타임 모니터링, 마이크로서비스 지원, 리액티브 프로그래밍 모델, 그리고 최신 애플리케이션 개발에 필요한 많은 다른 기능을 제공한다.

지금까지의 스프링 버전에서는 컴포넌트 및 다른 컴포넌트와의 관계를 나타내는 하나 이상의 XML 파일을 사용해서 빈을 상호 연결하도록 스프링 애플리케이션 컨텍스트에 알려주었다.

예를 들어, 다음 XML에서는 InventoryService 빈(재고 서비스)과 ProductService 빈(제품 서비스)을 선언하며, 생성자 인자를 사용해서 InventoryService 빈을 ProductService 빈에 연결한다.

```java
<bean id="inventoryService" 
			class="com.example.InventoryService" />

<bean id="productService" 
			class="com.example.ProductService" />
	<constructor-arg ref="inventoryService" />
</bean>
```

그러나 최신 버전의 스프링에서는 자바 기반의 구성configuration이 더 많이 사용된다. 

다음의 자바 기반 구성 클래스는 바로 앞의 XML 구성과 동일하다.

```java
@Configuration
public class ServiceConfiguration {
	@Bean
	public InventoryService inventoryService() {
		return new InventoryService();
}

	@Bean
	public ProductService productService() {
			return new ProductService(inventoryService());
	}
}
```

여기서 @Configuration 애노테이션annotation은 이것이 각 빈을 스프링 애플리케이션 컨텍스트에 제공하는 구성 클래스라는 것을 스프링에게 알려준다. 구성 클래스의 메서드에는 @Bean 애노테이션이 지정되어 있으며, 이것은 각 메서드에서 반환되는 객체가 애플리케이션 컨텍스트의 빈으로 추가되어야 한다는 것을 나타낸다(여기서는 기본적으로 각 빈의 ID가 해당 빈을 정의하는 메서드의 이름과 동일하다).

XML보다 자바 기반 구성이 더 강화된 타입 안전과 향상된 리팩토링 기능을 포함해 몇 가지 장점을 제공한다. 하지만 스프링은 자동으로 컴포넌트들을 구성할 수 있는 자동-구성 기능이 있어서 별도의 XML 구성이나 자바 구성이 없어도 된다. 따라서 자동-구성을 할 수 없을 경우에만 필요하다.

자동-구성은 **자동 연결(autowiring)**과 **컴포넌트 검색(component scanning)**이라는 스프링 기법을 기반으로 한다. 컴포넌트 검색을 사용해 스프링은 **자동으로** 애플리케이션의 classpath에 지정된 컴포넌트를 **찾은 후** 스프링 애플리케이션 **컨텍스트의 빈으로 생성**할 수 있다. 또한, 스프링은 자동 연결을 사용해 의존 관계가 있는 컴포넌트를 **자동으로 다른 빈에 주입(연결)**한다.

최근에는 스프링부트가 소개되면서 자동-구성 기능이 더욱 향상되었다. 스프링 부트는 생산성 향상을 제공하는 스프링 프레임워크의 확장으로 향상도니 자동-구성autoconfiguration 기능에 의해 환경 변수인 classpath를 기준으로 어떤 컴포넌트가 구성되고 연결되어야 하는지 알 수 있다.

이런 자동 구성은 빌드에 필요한 별도의 구성 코드(XML이나 자바의 어떤 것이든)를 현격히 줄여준다. 

스프링 부트 없이는 스프링 애플리케이션 개발을 상상하기 어려울 정도로 스프링 부트는 스프링 애플리케이션 개발을 향상시킨다. 이런 이유로 이 책에서는 스프링과 스프링 부트가 일심동체인 것처럼 간주한다. 따라서 될 수 있는 대로 스프링 부트를 많이 사용하고 별도의 구성 파일은 꼭 필요할 때마 사용할 것이다. 또한 스프링의 XML 구성은 이미 구식의 방법이므로 자바 기반의 구성에 중점을 둘 것이다.

## 1.2 스프링 애플리케이션 초기 설정

스프링 Initializr를 사용하는 방법은 다음과 같이 여러 가지가 있다.

- https://start.spring.io의 웹 애플리케이션에서
- 명령행에서 curl 명령을 사용해서
- 명령행에서 스프링 부트 CLICommand-Line Interface를 사용해서
- Spring Tool Suite IDE를 사용해서 새로운 프로젝트를 생성할 때
- IntelliJ IDEA IDE를 사용해서 새로운 프로젝트를 생성할 때
- NetBeans IDE를 사용해서 새로운 프로젝트를 생성할 때

각 방법의 자세한 내용은 이 책의 부록에서 설명한다.

그리고 이번 장과 이 책 전체에서는 필자가 선호하는 방법인 Spring Tool Suite의 스프링 Initializr 지원 기능을 사용해서 새로운 프로젝트를 생성하는 방법을 보여줄 것이다(이후로는 Spring Tool Suite를 줄여서 STS로 나타낼 것이다).

STS는 이클립스Eclipse를 기반으로 하는 스프링 IDE이며, 다른 IDE에는 없는 스프링 부트 대시보드Spring Boot Dashboard 기능도 제공한다.

기존의 자바 웹 애플리케이션은 WAR 파일로 패키징되며, JAR 파일은 라이브러리와 데스크톱 UI 애플리케이션의 패키징에 사용된다. JAR 패키징은 클라우드를 염두에 둔 선택이다. WAR 파일은 기존의 자바 애플리케이션 서버에 애플리케이션을 배포할 때는 적합하지만, 대부분의 클라우드 플랫폼에는 잘 맞지 않는다. 일부 클라우드 플랫폼(예를 들어, Cloud Foundry)에서는 WAR 파일을 배포하고 실행할 수 있다. 그러나 모든 자바 클라우드 플랫폼은 실행 가능한 JAR 파일을 사용한다. 

따라서 스프링 Initializr에서는 JAR 패키징을 기본값으로 사용한다. 만일 기존의 자바 애플리케이션 서버에 우리 애플리케이션을 배포하고자 한다면 WAR 패키징을 선택하고 웹 초기 설정 클래스를 포함시켜야 한다. 

기본적으로 프로젝트 위저드는 https://start.spring.io의 스프링 Initializr를 호출하여 프로젝트를 생성한다. 대개는 이 기본값을 변경할 필요가 없다. 그러나 어떤 이유로든 우리의 Initializr를 갖고 있다면(예를 들어, 기본 Initializr를 로컬 컴퓨터에 복사했거나 회사 방화벽 내부에서 실행되는 커스터마이징된 Initializr가 있을 때), 그것의 주소를 Base Url 필드에 입력한 후 Finish를 클릭하면 된다.

Finish를 클릭한 후에는 Initializr에 의해 생성된 프로젝트가 다운로드되어 우리 컴퓨터의 STS 작업 영역에 저장되고 로드되므로 애플리케이션 개발을 시작할 수 있다. 

우선, Initializr가 생성한 스프링 프로젝트의 구조를 자세히 살펴보자.

## 1.2.2 스프링 프로젝트 구조 살펴보기

전형적인 메이븐Maven 또는 그래들Gradle 프로젝트 구조라고 할 수 있다. 애플리케이션 소스 코드는 src/main/java, 테스트 코드는 src/test/java, 그리고 자바 리소스가 아닌 것은 src/main/resources에 저장된다. 프로젝트 구조에서 알아 둘 주요 항목(폴더나 파일)은 다음과 같다.

- mvnw와 mvnw.cmd: 이 파일들은 메이븐 래퍼 스크립트다. 메이븐이 각자 컴퓨터에 설치되어 있지 않더라도 이 스크립트를 사용하여 프로젝트를 빌드할 수 있다.
- pom.xml: 이것은 메이븐 빌드 명세(우리 프로젝트를 빌드할 때 필요한 정보)를 지정한 파일
- TacoCloudApplication.java: 스프링 부트 메인 클래스
- application.properties: 처음에는 이 파일에 내용이 없지만, 우리가 구성 속성을 지정할 수 있다. 구성 속성의 자세한 내용은 5장에서 알아볼 예정이다.
- static: 이것은 브라우저에 제공할 정적인 콘텐츠(이미지, 스타일시트, 자바스크립트 등)를 둘 수 있는 폴더다. 처음에는 비어 있다.
- templates: 이것은 브라우저에 콘텐츠를 보여주는 템플릿 파일을 두는 폴더다. 처음에는 비어 있지만, 여기서 조만간 Thymeleaf 템플릿을 추가할 것이다.
- TacoCloudApplicationTests.java: 이것은 스프링 애플리케이션이 성공적으로 로드되는지 확인하는 간단한 테스트 클래스다.

**pom.xml 파일**

<parent> 요소의 <version>에는 우리 프로젝트가 부모 POM(Project Object Model)으로 spring-boot-starter-parent를 갖는다는 것을 지정한다. 이 부모 POM은 스프링 프로젝트에 흔히 사용되는 여러 라이브러리의 의존성 관리를 제공한다. 따라서 이런 라이브러리들의 경우는 버전을 지정할 필요가 없다. 

Spring Web, Thymeleaf, Test 의존성 항목은 <artifactId>에 starter 단어를 포함하고 있음을 알 수 있다. 이것은 스프링 부트 스타터starter 의존성을 나타낸다. 이 의존성 항목들은 자체적으로 라이브러리 코드를 갖지 않고 다른 라이브러리의 것을 사용한다. 스타터 의존성은 다음 세 가지 장점이 있다.

- 우리가 필요로 하는 모든 라이브러리의 의존성을 선언하지 않아도 되므로 빌드 파일이 훨씬 더 작아지고 관리하기 쉬워진다.
- 라이브러리 이름이 아닌 기능의 관점으로 의존성을 생각할 수 있다. 따라서 만일 웹 애플리케이션을 개발한다면 웹 애플리케이션을 작성할 수 있게 해주는 라이브러리들을 일일이 지정하는 대신에 여기처럼 웹 스타터 의존성만 추가하면 된다.
- 라이브러리들의 버전을 걱정하지 않아도 된다. 스프링 부트에 포함되는 라이브러리들의 버전은 호환이 보장되므로 사용하려는 스프링 부트의 버전만 신경 쓰면 된다.

빌드 명세를 정의한 pom.xml 파일의 제일 끝에는 스프링 부트 플러그인이 지정된다. 이 플러그인의 중요 기능은 다음과 같다.

- 메이븐을 사용하는 애플리케이션을 실행할 수 있게 해준다.
- 의존성에 지정된 모든 라이브러리가 실행 가능 JAR 파일에 포함되어 있는지 그리고 런타임 시에 classpath에서 찾을 수 있는지 확인한다.
- 실행 가능 JAR 파일의 메인 클래스로 부트스트랩 클래스(여기서는 TacoCloudApplication)를 나타내는 매니페스트 파일을 JAR 파일에 생성한다

**애플리케이션의 부트스트랩(구동)**

실행 가능 JAR 파일에서 애플리케이션을 실행하므로 제일 먼저 시작되는 부트스트랩 클래스가 있어야 한다. 또한, 애플리케이션을 부트스트랩하기 위한 최소한의 스프링 구성도 있어야 한다. 부트스트랩 클래스인 TacoCloudApplication의 내용은 다음과 같다.

@SpringBootApplication 애노테이션은 이 코드가 스프링 부트 애플리케이션임을 나타낸다. 이 애노테이션은 다음 3개의 애노테이션이 결합한 것이다.

- @SpringBootConfiguration: 현재 클래스(TacoCloudApplication)를 구성 클래스로 지정한다. 아직은 구성이 많지 않지만, 필요하다면 자바 기반의 스프링 프레임워크 구성을 현재 클래스에 추가할 수 있다. 실제로는 이 애노테이션이 @Configuration: 애노테이션의 특화된 형태다.
- @EnableAutoConfiguration: 스프링 부트 자동-구성을 활성화한다. 자동-구성은 나중에 더 자세히 알아볼 것이다. 일단 지금은 이 애노테이션이 우리가 필요로 하는 컴포넌트들을 자동으로 구성하도록 스프링 부트에 알려준다는 것만 알아 두자.
- @ComponentScan: 컴포넌트 검색을 활성화한다. 이것은 @Component, @Controller, @Service 등의 애노테이션과 함께 클래스를 선언할 수 있게 해준다. 그러면 스프링은 자동으로 그런 클래스를 찾아 스프링 애플리케이션 컨텍스트에 컴포넌트로 등록한다.

또 다른 중요한 부분은 main() 메서드다. JAR 파일이 실행될 때 호출되어 실행되는 메서드다. 대부분의 경우 이 메서드는 표준화된 형태의 코드로 구성되며, 우리가 작성하는 모든 스프링부트 애플리케이션은 클래스 이름만 다를 뿐 이것과 비슷하거나 같은 메서드를 갖는다.

main() 메서드는 실제로 애플리케이션을 시작시키고 스프링 애플리케이션 컨텍스트를 생성하는 SpringApplication 클래스의 run() 메서드를 호출한다. run() 메서드에 전달되는 두 개의 매개변수는 구성 클래스와 명령행(command line) 인자다. 구성 클래스가 부트스트랩 클래스와 반드시 같아야 하는 것은 아니지만 대개 동일하게 지정한다.

부트스트랩 클래스의 내용은 변경할 필요가 없을 것이다. 간단한 애플리케이션의 경우는 하나 또는 두 개의 다른 컴포넌트를 부트스트랩 클래스에서 구성하는 것이 편리하다. 그러나 대부분의 애플리케이션에서는 자동-구성되지 않을 것들을 고려해 별도의 구성 클래스를 하나 생성하는 것이 좋다. 

**애플리케이션 테스트하기**

테스트 클래스인 TacoCloudApplicationTests의 코드에는 하나의 테스트 메서드가 있고 실행 코드는 없다. 그래도 이 테스트 클래스는 스프링 애플리케이션 컨텍스트가 성공적으로 로드될 수 있는지 확인하는 기본적인 검사를 실행한다. 따라서 만일 스프링 애플리케이션 컨텍스트의 생성을 저해하는 코드가 있다면 이 테스트가 실패하게 되므로 문제점을 찾아 해결할 수 있다.

@SpringBootTest는 스프링 부트 기능으로 테스트를 시작하라는 것을 JUnit에 알려준다. main() 메서드의 SpringApplication.run() 호출에 부합되는 테스트 클래스다. 

@SpringBootTest가 테스트의 스프링 애플리케이션 컨텍스트를 로드하는 작업을 수행하더라도 테스트 메서드가 없다면 아무 일도 하지 않는다. 그러나 리스트 1.3의 contextLoads()처럼 실행 코드는 없더라도 테스트 메서드가 있는 경우에는 @SpringBootTest 애노테이션이 작업을 수행하게 되어 스프링 애플리케이션 컨텍스트가 로드된다. 그리고 이 때 문제가 없는지 테스트하며, 만일 어떤 문제가 생기면 해당 테스트는 실패한다.

## 1.3 스프링 애플리케이션 작성하기

** 에러 생겨서 maven 대신 gradle로 진행 **

### 1.3.1 웹 요청 처리하기

스프링 MVC의 중심에는 컨트롤러가 있으며, 이것은 웹 요청과 응답을 처리하는 컴포넌트(또는 구성 요소)다. 웹 브라우저를 상대하는 애플리케이션의 경우에 컨트롤러는 선택적으로 모델 데이터를 채워서 응답하며, 브라우저에 반환되는 HTML을 생성하기 위해 해당 응답의 웹 요청을 뷰에 전달한다.

루트 경로의 웹 요청을 처리한 후 모델 데이터를 채우지 않고 해당 웹 요청을 홈페이지 뷰에 전달하는 간단한 컨트롤러 클래스를 작성해본다.

```java
package tacos;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class HomeController {
	
	@GetMapping("/") // 루트 경로인 /의 웹 요청 처리
	public String home() {
		return "home"; // 뷰 이름 반환
	}
}
```

@Controller 는 Controller 클래스가 컴포넌트로 식별되게 하는 것이 주 목적이다. 따라서 스프링의 컴포넌트 검색에서는 자동으로 HomeController 클래스를 찾은 후 스프링 애플리케이션 컨텍스트의 빈bean으로 HomeController의 인스턴스를 생성한다.

@Component, @Service, @Repository를 포함해서 소수의 다른 애노테이션들도 @Controller와 동일한 기능을 제공하므로 이런 애노테이션들 중 어느 것을 사용해도 된다. 그러나 @Controller를 선택한 이유는 애플리케이션에서의 컴포넌트 역할을 더 잘 설명해 주기 때문이다.

home() 메서드는 간단하며, @GetMapping 애노테이션이 지정되어 있다. 루트 경로인 /의 HTTP GET 요청이 수신되면 이 메서드가 해당 요청을 처리해야 한다. 여기서는 home 값을 갖는 String만 반환하고 다른 일은 하지 않는다. 이 값은 뷰의 논리적인 이름이다. 뷰는 여러 방법으로 구현될 수 있지만, Thymeleaf가 우리의 classpath에 지정되어 있으므로 여기서는 Thymeleaf를 사용해서 뷰 템플릿을 정의할 수 있다

논리적인 뷰 이름(여기서는 home) 앞에 /templates/가 붙고 끝에는 .html이 추가된 것이 템플릿 경로와 파일 이름이 되므로 여기서는 /templates/home.html이 된다. 그리고 우리 프로젝트에는 /src/main/resources/templates/home.html로 템플릿이 저장되어야 한다.

```java
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:th="http://www.thymeleaf.org">
<head>
<meta charset="EUC-KR">
<title>Taco Cloud</title>
</head>
<body>
  <h1>Welcome to...</h1>
  <img th:src="@{/images/TacoCloud.png}"/>
</body>
</html>
```

이미지와 같은 정적인 콘텐츠는 /src/main/resources/static 폴더에 위치해야 한다. 

### 1.3.3 컨트롤러 테스트하기

HTML 페이지의 컨텐츠에 대한 assertion을 설정하기 어려워서 웹 애플리케이션 테스트는 까다로울 수 있다. 다행히도 스프링은 웹 애플리케이션을 쉽게 테스트하는 강력한 테스트 지원 기능을 제공한다.

여기서는 루트 경로인 /의 HTTP GET 요청을 수행한 후 성공적인지, 그리고 뷰 ㅇ이름이 home이고 'Welcome to...' 메시지가 포함된 결과가 기대한 대로 나오는지 테스트한다.

```java
package tacos;

import static org.hamcrest.Matchers.containsString;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.view;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.test.web.servlet.MockMvc;

@WebMvcTest(HomeController.class) // HomeController의 웹페이지 테스트
public class HomeControllerTest {
	
	@Autowired
	private MockMvc mockMvc; // MockMvc를 주입

	@Test
	public void testHomePage() throws Exception {
		mockMvc.perform(get("/")) // GET / 를 수행
		
			.andExpect(status().isOk()) // HTTP 200이 되어야 한다
			
			.andExpect(view().name("home")) // home 뷰가 있어야 한다.
			
			.andExpect(content().string( // 컨텐츠에 Welcome to...가 포함되어야 한다.
					containsString("Welcome to...")));
	}
}
```

이 테스트에서 첫 번째로 주목할 것은 TacoCloudApplicationTests 클래스(리스트 1.3)에서 사용했던 것과 다른 애노테이션을 사용한다는 것이다. 여기서 HomeControllerTest는 @SpringBootTest 대신 @WebMvcTest 애노테이션을 사용한다. 이것은 스프링 부트에서 제공하는 특별한 테스트 애노테이션이며, 스프링 MVC 애플리케이션의 형태로 테스트가 실행되도록 한다. 즉, HomeController가 스프링 MVC에 등록되므로 우리가 스프링 MVC에 웹 요청을 보낼 수 있다.

@WebMvcTest는 또한 스프링 MVC를 테스트하기 위한 스프링 지원을 설정한다. 

이때 우리 테스트에서는 실제 서버를 시작하는 대신 스프링 MVC의 모의 mocking 메커니즘을 사용해도 충분하므로 모의 테스트를 하기 위해 우리 테스트 클래스에 MockMvc 객체를 주입(연결)한다.

testHomePage() 메서드에는 홈페이지에 대해 수행하고자 하는 테스트를 정의한다. 우선 루트 경로인 /의 HTTP GET 요청을 MockMvc 객체로 수행한다. 그리고 우리가 기대하는 것 expectation을 다음과 같이 설정한다.

- 응답은 반드시 HTTP 200 (OK) 상태가 되어야 한다.
- 뷰의 이름은 반드시 home이어야 한다.
- 브라우저에 보이는 뷰에는 반드시 ‘Welcome to....’ 텍스트가 포함되어야 한다.

만일 MockMvc 객체가 루트 경로인 /의 HTTP GET 요청을 수행한 후, 세 가지 기대 중 어느 하나라도 충족하지 않으면 테스트는 실패한다.

## 1.3.4 애플리케이션 빌드하고 실행하기

STS IDE를 선택했으므로 IDE 내부에서 애플리케이션을 실행하는 데 도움을 줄 수 있는 스프링 부트 대시보드라는 편리한 기능을 사용할 수 있다. 스프링 부트 대시보드는 IDE 창의 왼쪽 아래에 탭으로 나타난다(만일 보이지 않을 때는 다음과 같이 한다. 메인 메뉴의 Window  Show View  Other...를 선택한 후 Show View 대화상자의 Other 항목을 확장하고 Boot Dashboard를 선택한 후 Open 버튼을 클릭한다).

스프링 부트 대시보드의 local을 확장한 후 타코 클라우드 애플리케이션을 선택한 상태에서 시작(start) 버튼(제일 왼쪽에 있는  ㅁ>) 을 클릭하자. 애플리케이션이 바로 시작될 것이다. 그림 1.9에서는 이 시점의 스프링 부트 대시보드를 보여준다(여기에는 타코 클라우드 애플리케이션만 나타나 있다).

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/856d4834-ef13-4ac2-9a53-cdb0fb3372cd/Untitled.png)

스프링 부트 애플리케이션에는 실행에 필요한 모든 것이 포함된다. 따라서 톰캣과 같은 애플리케이션 서버에 별도로 애플리케이션을 설치할 필요가 없다. 여기서도 우리의 애플리케이션을 톰캣에 설치한 적이 없으며, 또한 톰캣도 설치하지 않았다. 톰캣이 우리 애플리케이션의 일부이기 때문이다! 

## 1.3.5 스프링 부트 DevTools

DevTools는 스프링 개발자에게 다음과 같은 개발 시점의 편리한 도구를 제공한다.

- 코드가 변경될 때 자동으로 애플리케이션을 다시 시작시킨다.
- 브라우저로 전송되는 리소스(예를 들어, 템플릿, 자바스크립트, 스타일시트)가 변경될 때 자동으로 브라우저를 새로고침한다.
- 템플릿 캐시를 자동으로 비활성화한다.
- 만일 H2 데이터베이스가 사용 중이라면 자동으로 H2 콘솔을 활성화한다

개발 시에만 사용되도록 했으므로 실제 운영에선 스스로 비활성화된다.

**자동으로 애플리케이션 다시 시작시키기**

DevTools는 변경을 감시하며, 뭔가 변경되었음을 알게 되면 자동으로 애플리케이션을 다시 시작시킨다.

더 자세히 말하면 DevTools를 사용 중일 때 애플리케이션은 **JVM에서 두 개의 클래스 로더loader에 의해 로드**된다. 그중 하나는 우리 자바 코드, 속성 파일, 프로젝트의 src/main/ 경로에 있는 모든 것과 함께 로드된다. 이것은 자주 변경될 수 있는 것이다. 나머지 클래스 로더는 자주 변경되지 않는 의존성 라이브러리와 함께 로드된다.

변경이 감지되는 경우 DevTools는 우리 프로젝트 **코드를 포함하는 클래스 로더만 다시 로드**하고 **스프링 애플리케이션 컨텍스트를 다시 시작**시킨다. 그러나 **다른 클래스 로더와 JVM은 그대로 둔다.** 따라서 애플리케이션이 시작하는데 걸리는 시간을 조금이나마 단축해 준다.

이런 전략의 단점은 애플리케이션이 **자동으로 다시 시작될 때 의존성 변경이 적용될 수 없다는 것**이다. 의존성 라이브러리를 포함하는 클래스 로더는 자동으로 다시 로드되지 않기 때문이다. 따라서 빌드 명세(pom.xml 파일)에 의존성을 추가, 변경, 삭제할 때는 애플리케이션을 새로 시작해야만 그러한 변경의 효과가 나타날 수 있다.

**자동으로 브라우저를 새로고침하고 템플릿 캐시를 비활성화하기** 

기본적으로 Thymeleaf와 FreeMarker 같은 템플릿에서는 템플릿의 파싱(코드 분석) 결과를 캐시에 저장하고 사용하도록 구성된다. 템플릿이 사용되는 모든 웹 요청마다 매번 다시 파싱 되지 않게 하기 위해서다. 이것은 조금이라도 성능상의 이점을 얻을 수 있어서 실제 운영 시에는 좋다.

그러나 개발 시점에는 템플릿 캐싱이 그리 유용하지 않다. 애플리케이션이 실행 중일 때 템플릿을 변경하고 브라우저를 새로고침하더라도 여전히 변경 전의 캐싱된 템플릿이 사용되므로 변경된 결과를 볼 수 없기 때문이다. 이 경우 애플리케이션을 다시 시작해야만 변경된 결과를 볼 수 있다.

DevTools는 모든 템플릿 캐싱을 자동으로 비활성화하여 이 문제를 해결한다. 따라서 템플릿을 얼마든지 변경하더라도 브라우저만 새로고침해주면 변경된 템플릿이 적용된다.

DevTools가 사용될 때는 우리 애플리케이션과 함께 자동으로 LiveReload (http://livereload.com/) 서버를 활성화한다. LiveReload 서버 자체는 그리 유용하지 않다. 그러나 이 서버와 부합되는 LiveReload 브라우저 플러그인과 연결될 때는 브라우저에 전달되는 거의 모든 것(예를 들어, 템플릿, 이미지, 스타일시트, 자바스크립트 등)에 변경이 생길 때 브라우저가 자동으로 새로고침된다. LiveReload는 구글 크롬, 사파리, 파이어폭스 브라우저의 플러그인을 갖고 있다. 브라우저에 LiveReload를 설치하는 방법에 관한 정보는 http://livereload.com/extensions/에 방문하면 알 수 있다.

**H2 콘솔**

만일 개발용으로 H2 데이터베이스의 사용을 선택한다면, 웹 브라우저에서 사용할 수 있는 H2 콘솔도 DevTools가 자동으로 활성화해 준다. 따라서 웹 브라우저에서 http://localhost:8080/h2-console에 접속하면 애플리케이션에서 사용하는 데이터를 알 수 있다.

## 1.3.6 리뷰하기

스프링이 하는 일을 이해하기 위해서 우선 빌드 명세를 봐야 한다.

빌드 명세를 정의한 pom.xml 파일에서 Web과 Thymeleaf 의존성을 선언했다. 이 두 의존성은 아래의 다른 의존성도 포함한다.

- 스프링의 MVC 프레임워크
- 내장 톰캣
- Thymeleaf와 Thymeleaf 레이아웃 dialect

이 때 스프링 부트의 자동-구성 라이브러리도 개입되므로 애플리케이션이 시작될 때 스프링부트 자동-구성에서 그런 의존성 라이브러리들을 감지하고 자동으로 다음 일을 수행한다.

- 스프링 MVC를 활성하기 위해 스프링 애플리케이션 컨텍스트에 관련된 빈들을 구성한다.
- 내장된 톰캣 서버를 스프링 애플리케이션 컨텍스트에 구성한다.
- Thymeleaf 템플릿을 사용하는 스프링 MVC 뷰를 나타내기 위해 Thymeleaf 뷰 리졸버를 구성한다.

요컨데 자동-구성이 모든 작업을 수행하므로 우리는 애플리케이션 구현 코드를 작성하는 데 집중할 수 있다.

## 1.4 스프링 살펴보기

스프링의 모든 것은 스프링 웹 폼의 체크박스 리스트에 나와 있다.

거기엔 100개 이상의 너무 많은 의존성이 있어 각자 살펴보고 여기서는 몇 가지 중요한 것만 언급한다.

## 1.4.1 핵심 스프링 프레임워크

핵심 스프링 프레임워크는 스프링에 있는 모든 것의 기반이다. 핵심 컨테이너와 의존성 주입 프레임워크 외에 몇 가지 다른 기능도 제공한다.

그 중 하나가 스프링의 웹 프레임워크인 스프링 MVC다. HTML이 아닌 출력을 생성하는 REST API를 만들 때도 스프링 MVC를 이용할 수 있다. 이는 추후 다룸

핵심 스프링 프레임워크는 템플릿 기반의 JDBC 지원을 포함해 기본적인 데이터 퍼시스턴스 지원도 제공한다. 

스프링의 가장 최신 버전에는 리액티브 프로그래밍 지원이 추가되었다. 여기에는 스프링 MVC 개념의 스프링 WebFlux라는 새로운 리액티브 웹 프레임워크가 포함된다. 스프링의 리액티브 프로그래밍 모델은 10, 11, 12장에서, 특히 스프링 WebFlux는 10장에서 알아본다.

## 1.4.2  스프링 부트

스타터 의존성과 자동-구성 외에도 스프링 부트는 다음의 다른 편리한 기능도 제공한다.

- 액추에이터Actuator는 애플리케이션의 내부 작동을 런타임 시에 살펴볼 수 있는 기능을 제공하며, 여기에는 메트릭metric, 스레드 덤프 정보, 애플리케이션의 상태, 애플리케이션에서 사용할 수 있는 환경 속성이 포함된다.
- 환경 속성의 명세
- 핵심 프레임워크에 추가되는 테스트 지원

게다가 스프링 부트는 스프링 부트 CLIcommand-line interface(명령행 인터페이스)를 제공한다. 스프링 부트 CLI를 사용하면 애플리케이션 전체를 그루비 스크립트들로 작성하여 명령행에서 실행할 수 있다. 이 책에서는 스프링 부트 CLI가 우리 요구에 적합한 경우에만 사용할 것이다.

## 1.4.3  스프링 데이터

기본적인 데이터 퍼시스턴스 지원은 핵심 스프링 프레임워크에 포함되어 있지만, 스프링 데이터는 이외에도 여러 기능을 제공한다. 즉, 간단한 자바 인터페이스로 우리 애플리케이션의 데이터 리퍼지터리를 정의할 수 있다. 이때 데이터를 저장하고 읽는 메서드를 작명 규칙을 사용해서 정의한다.

게다가 스프링 데이터는 서로 다른 종류의 데이터베이스와 함께 사용될 수 있다. 예를 들어, 관계형 데이터베이스인 JPA, 문서형 데이터베이스인 Mongo, 그래프형 데이터베이스인 Neo4j 등이다.

## 1.4.4  스프링 시큐리티

애플리케이션 보안은 항상 중요한 주제다. 다행스럽게도 스프링은 강력한 보안 프레임워크를 갖고 있다.

스프링 시큐리티는 인증authentication, 허가authorization, API 보안을 포함하는 폭넓은 범위의 애플리케이션 보안 요구를 다룬다. 스프링 시큐리티의 범위가 너무 넓어서 이 책에서 모두 다루기는 어렵지만, 가장 흔히 사용하는 몇 가지 경우를 4장과 12장에서 알아볼 것이다.

## 1.4.5  스프링 통합과 배치

어떤 시점이든 대부분의 애플리케이션은 다른 애플리케이션 또는 같은 애플리케이션의 서로 다른 컴포넌트를 통합Integration할 필요가 생긴다. 이런 요구사항을 해결하기 위한 이미 알려진 몇 가지 애플리케이션 통합 패턴이 있다. 스프링 통합과 스프링 배치Batch는 스프링 기반 애플리케이션의 이런 패턴 구현을 제공한다.

스프링 통합은 데이터가 사용 가능한 즉시 처리되는 실시간 통합을 한다. 반면에 스프링 배치에서는 다량의 데이터가 처리되는 시점을 트리거(대개 시간을 기준하는 트리거)가 알려줄 때 데이터가 수집 처리되는 배치 통합을 처리해 준다. 스프링 배치와 스프링 통합 모두 9장에서 알아볼 것이다.

## 1.4.6  스프링 클라우드

애플리케이션을 거대한 하나의 단일체로 개발하는 대신 마이크로서비스라는 여러 개의 개별적인 단위들로 합성하는 것이다.

마이크로서비스는 애플리케이션 개발과 실행에서 많은 관심을 받는 주제다. 그러나 그렇게 하려면 도전이 필요하며, 이때 스프링을 사용해서 클라우드 애플리케이션을 개발하기 위한 프로젝트들의 모음인 스프링 클라우드를 사용한다.

스프링 클라우드에서는 많은 것을 다루므로 이 책에서 모두 알아보는 것은 불가능하다. 따라서 이 책에서는 13, 14, 15장에서 스프링 클라우드의 가장 중요한 컴포넌트 중 일부를 알아볼 것이다. 스프링 클라우드와 마이크로서비스의 더 자세한 내용은 다음 책을 참고하기 바란다. 《스프링 마이크로서비스 코딩 공작소(Spring Microservices in Action)》(존 카넬 저, 정성권 역,

길벗, 2018)