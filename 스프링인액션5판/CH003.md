# CH03 데이터로 작업하기

이 장에서 배우는 내용

- 스프링 JdbcTemplate 사용
- SimpleJdbcInsert 사용해 데이터 추가하기
- 스프링 데이터를 사용해서 JPA 선언하고 사용하기

동적인 애플리케이션이 정적 앱과 차별화되는 점은 사용자에게 보여주고 저장하는 데이터다. 

이 장에서는 Data persistence(저장 및 지속성 유지)를 추가하고 boilerplace code(상용구 코드)를 없애기 위해 스프링의 JDBC 지원 기능을 사용한다. 그 다음 더 많은 코드를 줄이기 위해 JPA(Java Persistence API)로 데이터 리포지터리를 사용할 수 있도록 한다.

## 3.1 JDBC를 사용해서 데이터 읽고 쓰기

오랜기간 관계형 데이터베이스와 SQL은 데이터 퍼시스턴스의 최우선 선택으로 쓰여왔다.

최근 대체 가능한 여러 데이터베이스가 출현했으나 빠른 시일 내에 그런 위치를 빼앗기진 않을 것이다.

관계형 데이터를 사용할 경우 자바 개발자들이 선택할 수 있는 몇 가지 중 가장 많이 사용하는 2가지 방법이 JDBC와 JPA다. 

스프링의 JDBC 지원은 JdbcTemplate 클래스에 기반을 둔다. JdbcTemplate은 JDBC를 사용할 때 요구되는 모든 형식적이고 상투적인 코드 없이 개발자가 관계형 DB에 대한 SQL 연산을 수행할 수 있는 방법을 제공한다.

JdbcTemplate이 무슨 일을 하는지 이해하기 위해 우선 다음 예를 보자.

여기서는 JdbcTemplate을 사용하지 않고 자바로 간단한 SQL 쿼리를 수행하는 방법을 보여준다.

```java
@Override
public Ingredient findById(String id) {
 Connection connection = null;
 PreparedStatement statement = null;
 ResultSet resultSet = null;
 try {
	 connection = dataSource.getConnection();
	 statement = connection.prepareStatement(
			 "select id, name, type from Ingredient where id = ?");
	 statement.setString(1, id);
	 resultSet = statement.executeQuery();
	 Ingredient ingredient = null;
	 if (resultSet.next()) {
	 ingredient = new Ingredient(
			 resultSet.getString("id"),
			 resultSet.getString("name"),
			 Ingredient.Type.valueOf(resultSet.getString("type")));
	 }
	 return ingredient;
 } catch (SQLException e) {
 // 여기서는 무엇을 해야 할까?
	} finally {
	 if (resultSet != null) {
		 try {
			 resultSet.close();
	 } catch (SQLException e) {}
	 }
	 if (statement != null) {
		 try {
			 statement.close();
		 } catch (SQLException e) {}
		 }
	 if (connection != null) {
	 try {
			 connection.close();
		 } catch (SQLException e) {}
	 }
 }
	 return null;
}
```

SQLException은 catch 블록으로 반드시 처리해야 하는 checked 예외다. 그러나 데이터베이스 연결 생성 실패나 작성 오류가 있는 쿼리와 같은 대부분의 흔한 문제들은 catch 블럭에서 해결될 수 없으므로 현재 메서드를 호출한 상위 코드로 예외 처리를 넘겨야 한다.

다음에는 이것과 대조되는 JdbcTemplate 사용 메서드를 알아보자.

```java
private JdbcTemplate jdbc;

@Override
public Ingredient findById(String id) {
 return jdbc.queryForObject(
		 "select id, name, type from Ingredient where id=?",
		 this::mapRowToIngredient, id);
}

private Ingredient mapRowToIngredient(ResultSet rs, int rowNum)
	 throws SQLException {
 return new Ingredient(
		 rs.getString("id"),
		 rs.getString("name"),
		 Ingredient.Type.valueOf(rs.getString("type")));
}
```

위의 코드보다 훨씬 간단한데 명령문이나 데이터베이스 연결 객체를 생성하는 코드가 아예 없다. 그리고 메서드의 실행이 끝난 후 그런 객체들을 클린업하는 코드 또한 없다. 또한, catch 블럭에서 올바르게 처리할 수 없는 예외를 처리하는 어떤 코드도 없다. 쿼리를 수행하고(JdbcTemplate의 queryForObject() 메서드), 그 결과를 Ingredient 객체로 생성하는(mapRowToIngredient() 메서드) 것에 초점을 두는 코드만 존재한다.

## 3.1.1 JdbcTemplate 사용하기

객체를 db에 저장하고자 할 때는 해당 객체를 고유하게 식별해 주는 필드를 하나 추가하는 것이 좋다. 

@Repository는 @Controller와 @Component 외에 스프링이 정의하는 몇 안되는 스테레오타입 애노테이션 중 하나다. 지정해두면 스프링 컴포넌트 검색에서 이 클래스를 자동으로 찾아서 스프링 애플리케이션 컨텍스트 빈으로 생성해 준다.

그리고 그 레포지터리의 빈이 생성되면 @Autowired 애노테이션을 통해 스프링이 해당 빈을 JdbcTemplate에 주입(연결)한다. JdbcIngredientRepoistory의 생성자에서 JdbcTemplate 참조를 인스턴스 변수에 저장한다. 이 변수는 데이터베이스의 데이터를 쿼리하고 추가하기 위해 다른 메서드에서 사용될 것이다. 

findAll() 메서드는 JdbcTemplate의 query() 메서드를 사용한다. 쿼리 메서드는 두 개의 인자를 받는데 첫 번째 인자에는 쿼리를 수행하는 SQL이며, 두 번째 인자는 스프링의 RowMapper 인터페이스를 우리가 구현한 mapRowToIngredient 메서드다. 이 메서드는 쿼리로 생성된 결과 세트(ResultSet 객체)의 행 개수만큼 호출되며, 결과세트의 모든 행을 각각 객체(여기서는 식자재를 나타내는 Ingredient)로 생성하고 List에 저장한 후 반환한다. query()에서는 또한 쿼리에서 요구하는 매개변수들의 내역을 마지막 인자로 받을 수 있다. 그러나 여기선 그런 매개변수가 필요하지 않아 생략했다.

findById() 메서드는 하나의 Ingredient 객체만 반환한다. 따라서  query() 대신 JdbcTemplate의 queryForObject() 메서드를 사용한다. 이 메서드는 query()와 동일하게 실행되지만 객체의 List를 반환하는 대신 하나의 객체만 반환한다. queryForObject() 메서드의 첫 번째와 두 번째 인자는 쿼리와 동일하며 세 번째 인자로는 검색할 행의 id를 전달한다. 그러면 이 id가 첫 번째 인자로 전달된 SQL에 있는 물음표? 대신 교체되어 쿼리에 사용된다.

findAll(0과 findById() 모두의 두 번째 인자로는 스프링 RowMapper 인터페이스를 구현한 mapRowToIngredient() 메서드의 참조가 전달된다. 이처럼 메서드 인자로 다른 메서드의 참조를 전달할 수 있는 것은 자바 8에서 메서드 참조와 람다가 추가되었기 때문이며 JdbcTemplate을 사용할 때 매우 편리하다. 그러나 종전처럼 RowMapper 인터페이스의 mapRow() 메서드를 구현하는 방법을 사용할 수도 있다. 

스키마를 정의한 schema.sql 파일이 애플리케이션 classpath의 루트 경로에 있으면 애플리케이션이 시작될 때 schema.sql 파일의 SQL이 사용 중인 데이터베이스에서 자동 실행된다. 

src/main/resources 폴더에 저장하면 된다. 

JDBC를 사용해 데이터를 저장하는 방법에는 2가지가 있다.

- 직접 update() 메서드 사용
- SimpleJdbcInsert 래퍼(wrapper) 클래스를 사용

@SessionAttributes("order") : 하나의 세션에서 생성되는 Taco 객체와 다르게 주문은 다수의 HTTP 요청에 걸쳐 존재해야 한다. 다수의 타코를 생성하고 그것들을 하나의 주문으로 추가할 수 있게 하기 위해서다. 이 때 클래스 수준의 @SessionAttriutes 애노테이션을 주문과 같은 모델 객체에 지정하면 된다. 그러면 세션에서 계속 보존되면서 다수의 요청에 걸쳐 사용될 수 있다.

@ModelAttributes(name = "order") : Order 객체가 모델에 생성되도록 해준다. 

### 이해 안되는 부분

책 93p, pdf 118p

하나의 타코 디자인을 실제로 처리(저장)하는 일은 processDesign() 메서드에서 수행된다.
이제는 이 메서드에서 Taco 및 Errors 객체와 더불어 Order 객체도 인자로 받는다. Order 매개변수에는 @ModelAttribute 애노테이션이 지정되었다. 이 매개변수의 값이 모델로부터 전달되어야 한다는 것과 스프링 MVC가 이 매개변수에 요청 매개변수를 바인딩하지 않아야 한다는 것을 나타내기 위해서다. 전달된 데이터의 유효성 검사를 한 후 processDesign()에서는 주입된 TacoRepository를 사용해서 타코를 저장한다. 그다음에 세션에 보존된 Order에 Taco 객체를 추가한다.

## SimpleJdbcInsert를 사용해서 데이터 추가하기

생략